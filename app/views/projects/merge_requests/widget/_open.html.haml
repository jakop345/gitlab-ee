- approvers_names = @merge_request.approvers_left.map(&:name).to_json
- approvals_required = @merge_request.approvals_required
- approvals_left = @merge_request.approvals_left
- content_for :page_specific_javascripts do
  = page_specific_javascript_tag('merge_request_widget/widget_bundle.js')

#merge-request-widget-app.mr-state-widget{'data-approved-by-users' => @merge_request.approved_by_users.to_json, 'data-approver-names' => approvers_names,'data-approvals-left' => approvals_left, 'data-approvals-required' => approvals_required, 'data-endpoint'=> '/myendpoint/tho'}
  = render 'projects/merge_requests/widget/heading'
  .mr-widget-body
    -# After conflicts are resolved, the user is redirected back to the MR page.
    -# There is a short window before background workers run and GitLab processes
    -# the new push and commits, during which it will think the conflicts still exist.
    -# We send this param to get the widget to treat the MR as having no more conflicts.
    - resolved_conflicts = params[:resolved_conflicts]

    - if Gitlab::Geo.secondary?
      = render 'projects/merge_requests/widget/open/geo'
    - if @project.archived?
      = render 'projects/merge_requests/widget/open/archived'
    - elsif @project.above_size_limit?
      = render 'projects/merge_requests/widget/open/size_limit_reached'
    - elsif @merge_request.branch_missing?
      = render 'projects/merge_requests/widget/open/missing_branch'
    - elsif @merge_request.has_no_commits?
      = render 'projects/merge_requests/widget/open/nothing'
    - elsif @merge_request.unchecked?
      = render 'projects/merge_requests/widget/open/check'
    - elsif @merge_request.cannot_be_merged? && !resolved_conflicts
      = render 'projects/merge_requests/widget/open/conflicts'
    - elsif @merge_request.work_in_progress?
      = render 'projects/merge_requests/widget/open/wip'
    - elsif @merge_request.requires_approve? && !@merge_request.approved?
      %approvals-body{':approver-names' => 'approvals.approverNames', ':approvals-left' => 'approvals.approvalsLeft', ':user-can-approve' => 'approvals.userCanApprove', ':user-has-approved' => 'approvals.userHasApproved'}
    - elsif @merge_request.merge_when_build_succeeds?
      = render 'projects/merge_requests/widget/open/merge_when_build_succeeds'
    - elsif !@merge_request.can_be_merged_by?(current_user)
      = render 'projects/merge_requests/widget/open/not_allowed'
    - elsif !@merge_request.mergeable_ci_state? && (@pipeline.failed? || @pipeline.canceled?)
      = render 'projects/merge_requests/widget/open/build_failed'
    - elsif @merge_request.should_be_rebased?
      = render 'projects/merge_requests/widget/open/rebase'
    - elsif !@merge_request.mergeable_discussions_state?
      = render 'projects/merge_requests/widget/open/unresolved_discussions'
    - elsif @merge_request.can_be_merged? || resolved_conflicts
      = render 'projects/merge_requests/widget/open/accept'

  - if mr_closes_issues.present?
    .mr-widget-footer
      %span
        %i.fa.fa-check
        Accepting this merge request will close #{"issue".pluralize(mr_closes_issues.size)}
        = succeed '.' do
          != markdown issues_sentence(mr_closes_issues), pipeline: :gfm, author: @merge_request.author
        = mr_assign_issues_link

  - if @merge_request.approvals.any?
    %approvals-footer{':approved-by-users' => 'approvals.approvedByUsers', ':approver-names' => 'approvals.approverNames', ':approvals-left' => 'approvals.approvalsLeft', ':user-can-approve' => 'approvals.userCanApprove', ':user-has-approved' => 'approvals.userHasApproved', 'pending-avatar-svg' => custom_icon('icon_dotted_circle'), 'checkmark-svg' => custom_icon('icon_checkmark') }

